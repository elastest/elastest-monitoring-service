{
package session

import(
//	"stamp"
	"strconv"
    "github.com/elastest/elastest-monitoring-service/go_EMS/parsers/common"
    dt "github.com/elastest/elastest-monitoring-service/go_EMS/datatypes"
)

}

Input  <- _? d:(Declaration*)  EOF {
       // returns a []interface{} where all elements are Filter,Session,Stream or Trigger
       return d,nil
       }

Version <- VERSION ver:VersionNum _?  { return ver,nil //TODO, check for version number}

VersionNum <- ([0-9'.']+) {
  	   return common.Version{string(c.text)},nil
}

Declaration <- f:Filter { return f,nil }
	    / s:Session { return s,nil }
	    / s:Stream  { return s,nil }
	    / t:Trigger { return t,nil }
	    / p:PredDef { return p,nil }


PredDef <- PRED n:Name ":=" p:common.Predicate {
	return newPredicateDeclaration(n,p),nil
}



Session <- SESSION n:Name ":" _? "[" _? beg:common.Predicate "," _? end:common.Predicate "]" _? {
	return newSessionDeclaration(n,beg,end),nil
}

Stream <- STREAM t:Type n:Name ":=" _? e:StreamExpr {
       return newStreamDeclaration(t,n,e),nil
}

Type <- INT     { return IntT, nil  }
     /  BOOL    { return BoolT, nil }
     /  STRING  { return StringT,nil}

StreamExpr <- '(' _? s:StreamExpr ')' _? {
	   return s,nil
       }
       / b:Builtin "(" _? s:Name WITHIN w:Name _? ")" _? {
          return newAggregatorExpr(b,s,w), nil
       }
       / IF p:common.Predicate THEN a:StreamExpr ELSE b:StreamExpr {
       	 return newIfThenElseExpr(p,a,b),nil
       }
       / i:IntPathExpr { return i,nil }
       / s:StrPathExpr { return s,nil }
       / IF p:common.Predicate THEN s:StreamExpr {
          return newIfThenExpr(p,s),nil
       }
       / p:common.Predicate { //Boolean Expression
       	 return newPredExpr(p),nil
       }
       / n:NumExpr {
       	 return n,nil
       }

Builtin <- AVG { return "avg",nil }
	/ COUNT { return "count",nil }

IntPathExpr <- "e.getint(" _? p:JSONPath _? ")" _? {
      return newIntPathExpr(p),nil		
}
StrPathExpr <- "e.getstr" _? '(' _? p:JSONPath _? ")" _? {
      return newStringPathExpr(p),nil		
}



Trigger <-TRIGGER p:common.Predicate DO a:Action _? {
	return newTrigger(p,a),nil
}

Action <- EMIT n:Name ON t:common.Tag _? {
       return newEmitAction(n,t),nil
}

Name <- n:common.Identifier _? { return n.(common.Identifier),nil }

Filter <- WHEN p:common.Predicate DO t:common.Tag _? {
       return Filter{p.(common.Predicate),t.(common.Tag).Tag},nil
       }

//
// IDEA: Instead of replicating all Boolean expressions for
//       stream declarations of type Boolean (from preds on events)
//       it is better to just have a larger expression parser for
//       the Boolean type and reject semantically expressions for
//       event predicates that fetch streams
//

Predicate <- a:Ands    b:(OrExpr*)  { return common.NewOrPredicate(a,b),nil }
Ands      <- a:NegExpr b:(AndExpr*) { return common.NewAndPredicate(a,b),nil }
AndExpr   <- "/\\" _? p:NegExpr      { return p,nil }
OrExpr    <- "\\/" _? p:Ands         { return p,nil }
NegExpr   <- "~" _? p:NegExpr        { return common.NewNotPredicate(p),nil }
	 /  p:Primary             { return p,nil }
Primary   <- '(' _? p:common.Predicate ')' _?  { return p,nil }
         / a:AtomicPredicate	 { return a,nil }
AtomicPredicate <- p:PathPredicate  { return p,nil }
	  / p:StrPredicate     { return p,nil }
	  / p:HasTagPredicate  { return p,nil }
	  / p:"true" _? { return common.True,nil }
	  / p:"false" _? { return common.False,nil }
	  / n:NumComparison  { return n,nil }
          / n:NamedPredicate  { return n,nil }   

//
// NumericComparison and Expressions
//
NumComparison <- a:NumExpr "<"  _? b:NumExpr { return newNumLess(a,b),nil }
              /  a:NumExpr "<=" _? b:NumExpr { return newNumLessEq(a,b),nil }
              /  a:NumExpr "="  _? b:NumExpr { return newNumEq(a,b),nil }
              /  a:NumExpr ">"  _? b:NumExpr { return newNumGreater(a,b),nil }
              /  a:NumExpr ">=" _? b:NumExpr { return newNumGreaterEq(a,b),nil }
	      /	 a:NumExpr "!=" _? b:NumExpr { return newNumNotEq(a,b),nil }

NumExpr  <- a:Mults "+" _? b:Mults { return newPlusExpr(a,b),nil  }
          / a:Mults "-" _? b:Mults { return newMinusExpr(a,b),nil }
	  / a:Mults                { return a,nil}
Mults    <- a:BasicNumExpr "*" _? b:Mults { return newMulExpr(a,b),nil }
          / a:BasicNumExpr "/" _? b:Mults { return newDivExpr(a,b),nil }
	  / a:BasicNumExpr { return a,nil}
BasicNumExpr <- '(' _? n:NumExpr ')' _?   { return n,nil }
           / a:AtomicNumExpr { return a,nil }
AtomicNumExpr <- n:NumStream { return newNumStreamExpr(n),nil }
	      / l:IntLiteral { return l,nil }

NumStream <- n:Name { return n,nil }

NumLiteral <- p:([0-9]+('.'[0-9]+)?) {
	      x,err := strconv.ParseFloat(p.(string),32)
	      return newFloatLiteralExpr(x), err
	   }
IntLiteral <- p:('-'?[0-9]+) {
              n,err := strconv.Atoi(p.(string))
	      return newIntLiteralExpr(n),err
	   }

NamedPredicate <- n:Name _? { return common.NewNamedPredicate(n),nil  } 

PathPredicate <- "e.path" _? "(" _? p:JSONPath _? ")" _? {
	      return common.NewPathPredicate(p),nil		
}

StrPredicate <- "e.strcmp(" _? p:JSONPath _? "," _? s:QuotedString _?")" _? {
	     return common.NewStrPredicate(p,s),nil
}
HasTagPredicate <- "e.tag(" _? t:common.Tag _? ")" _? {
		return common.NewTagPredicate(t),nil
}

QuotedString <- ('"'(([^'"''\\']*('\\'.[^'"''\\']*)*))'"')  {
	        str := string(c.text)
	     	inner := str[1:len(str)-1]
     	        return common.NewQuotedString(inner),nil
        }
	
JSONPath <- ([a-zA-Z0-9]+('.'[a-zA-Z0-9]+)*) {
	 return common.NewPathName(string(c.text)),nil
	 }	 

Identifier <- ([a-zA-Z]['_''-''@'a-zA-Z0-9]*) {
	   // IMPORTANT: cannot have '.' to distinguish from "e.path" "e.strcmp"
	   return common.Identifier{string(c.text)}, nil
	   }

String   <- ([a-zA-Z0-9'#''_''-''@']+) 

Alphanum <- ([a-zA-Z0-9]+) { return common.Alphanum{string(c.text)},nil }

Tag  "tag"      <- ( '#'[a-zA-Z](['_''-''.'a-zA-Z0-9])* )    { return common.Tag{dt.Channel(string(c.text))},nil }

_ "whitespace" <- [ \t\n\r]+

//EOL     <- _? Comment? ("\r\n" / "\n\r" / "\r" / "\n" / EOF)
EOL     <- ("\r\n" / "\n\r" / "\r" / "\n")

Comment <- "//" [^\r\n]*

EOF     <- !.

// Keywords

SESSION <- "session" _
BEGIN   <- "begin" _
END     <- "end" _
PRED    <- "pred" _
WITHIN  <- "within" _
VERSION <- "version" _
STREAM <- "stream" _
INT    <- "int" _
BOOL   <- "bool" _
STRING <- "string" _
AVG <- "avg" _?
COUNT   <- "count" _?
TRIGGER <- "trigger" _
DO      <- "do" _
EMIT    <- "emit" _
ON      <- "on" _
WHEN <- "when" _ 
DO   <- "do" _ 
IF   <- "if" _
THEN <- "then" _
ELSE <- "else" _
